#define _GNU_SOURCE
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "database.h"
#include <sys/stat.h>
#include <stdbool.h>

/* 	DATABASE
 *	There's some documentation throughout the code, and an example usage at the bottom of the file.
 */

/* Node Functions */

struct node* node_init(char *key) {
	struct node *n = (struct node*)malloc(sizeof(struct node));
	n->next = NULL;
	n->prev = NULL;
	
    strncpy ( n->key, key, sizeof(n->key) );
	
	int i;
	for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
        memset(n->col_values[i], '\0', sizeof(n->col_values[i]));
        //strncpy(n->col_values[i], "", sizeof(""));
	}

	return n;
}

/* Linked List Functions */

int Table_ishead(struct Table *t, struct node *n) {
	if(n == t->head)
		return 1;
	else
		return 0;
}

int Table_istail(struct Table *t, struct node *n) {
	if(n == t->tail)
		return 1;
	else
		return 0;
}

/**
 * @brief 	Initialize a linked list.
 * @param 	name - the name of the table to create
 * @return	a new linked list
 */
struct Table* Table_init (char *name) {
	struct Table *t = (struct Table*)malloc(sizeof(struct Table));
    strncpy(t->name, name, sizeof(t->name));
    t->head = NULL;
    t->tail = NULL;

	int i;
	for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
        memset(t->col_names[i], '\0', sizeof(t->col_names[i]));
        //strncpy(t->col_names[i], "", sizeof(t->col_names[i]));
		t->col_string_size[i] = 0;
	}

    return t;
}

// 0 string size for int, > 0 string size for char of that size
// Return -1 if all columns are full, 0 if insert was successful
int Table_addColumn (struct Table *t, char *columnName, int col_string_size) {
	int insert_index = -1;
	int i;
	for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
        if(strlen(t->col_names[i]) == 0) {
            insert_index = i;
            break;
		}
	}
	if (insert_index == -1) {
        return -1;
	}
	else {
		strncpy(t->col_names[insert_index], columnName, strlen(columnName));
		t->col_string_size[insert_index] = col_string_size;
		return 0;	
	}
}


int Table_updateValue (struct Table *t, struct node *n, char *columnName, char *value) {
	int update_index = -1;
    int ret = 0;
	int i;
	for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
		if(strcmp(t->col_names[i], columnName) == 0) {
			update_index = i;
		}
	}
	if(update_index == -1) {
		ret = -3;
	}
	else {
        int size = t->col_string_size[update_index];
        if(size == 0 && strtol(value, NULL, 10) == 0 && strcmp(value, "0") != 0) {
            ret = -4;
        }
        else if (size > 0 && size < strlen(value)) {
            ret = -4;
        }
        else {
		    strncpy(n->col_values[update_index], value, strlen(value));
        }
	}
    return ret;
}

/**
 * @brief 	Append a new node to the list
 * @param 	t - the linked list to insert into
 * @param 	key - the key to use
 * @param 	value - the value to use
 * return -1 if column does not exist
 */
int Table_append (struct Table *t, char *key, char *columnName, char *value) {
    struct node *n = node_init(key);
    int ret = Table_updateValue(t, n, columnName, value);
    if (ret == 0) {
        if(t->head == NULL ) {
            n->prev = NULL;
            n->next = NULL;

            t->head = n;
            t->tail = t->head;
        }
        else {
            n->prev = t->tail;

            t->tail->next = n;
            t->tail = n;
        }
    }
    return ret;
}

/**
 *  @brief  Print an entire linked list to screen, starting from head 
 */
void Table_dump (struct Table *t) {
    printf("--- '%s' Start ---\n", t->name);
    printf("Columns\n");
    int i;
    for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
        if(strlen(t->col_names[i]) != 0) {
            printf("%s : %d\n", t->col_names[i], t->col_string_size[i]);
        }
    }
    printf("\n");
    if(t->head != NULL) {
        struct node *n = t->head;
        while(n != NULL) {
            if(Table_ishead(t, n))
                printf("HEAD ");
            if(Table_istail(t, n))
                printf("TAIL ");
            printf("\n\t%s\n", n->key);
			int i;
			for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
				if(strlen(n->col_values[i]) != 0) {
                    printf("\t\t%s : %s \n", t->col_names[i], n->col_values[i]);
                }
			}

            n = n->next;
        }
    }
    printf("--- '%s' End ---\n", t->name);
}

/*
 *  @brief  Search a linked list   
 *  @param  The key to search for 
 *  @return The found node 
 */
struct node* Table_get_node (struct Table *t, char *key) {
	struct node *curr = t->head;

	while(curr != NULL) {
		if(strcmp(curr->key, key) == 0) {
			return curr;
		}
		curr = curr->next;
	}

	return NULL;
}

/**
 * @brief 	Delete a node from a linked list
 * @param 	t - the linked list to delete from
 * @param 	key - the key of the node to be deleted
 * @return	-1 if key/node is not found. 0 on success
 */
int Table_delete (struct Table *t, char *key) {
	struct node *tbd = Table_get_node(t, key);

    if(tbd == NULL) {
        return -1;
    }
    else {
        if(t->head == tbd && t->tail == tbd) {
            free(t->head);
            t->head = NULL;
        }
        else {
            if(Table_ishead(t, tbd)) {
                t->head = tbd->next;
                t->head->prev = NULL;
                tbd = NULL;
            }
            else if(Table_istail(t, tbd)) {
                t->tail = tbd->prev;
                t->tail->next = NULL;
                free(tbd);
                tbd = NULL;
            }
            else {
                tbd->prev->next = tbd->next;
                tbd->next->prev = tbd->prev;
                free(tbd);
            }
            free(tbd);
            tbd = NULL;
	    }	
        return 0; 
	}
}

/**
 * @brief 	Insert or update a key / value pair to the linked list
 * @param 	t - the linked list to insert into or update
 * @param 	key - the key to be used
 * @param 	val - the value to be used
 * @return	-1 if key/node is not found. 0 on success
 */
int Table_set (struct Table *t, char *key, char *columnName, char *value) {
    struct node *n = Table_get_node(t, key);
    if (n == NULL) {
        return Table_append(t, key, columnName, value);
    }
    else {
		return Table_updateValue(t, n, columnName, value);
    }
}

/* Database Functions */

/**
 * @brief 	Initializes a new database struct
 * @return	the new database
 */
struct database* DB_init(char *data_directory) {
    struct database *db = (struct database*)malloc(sizeof(struct database)); 
    db->head = NULL;
    db->tail = NULL;

    if(data_directory == NULL) {
        db->db_file = NULL;
    }
    else {
        mkdir(data_directory, 0777);
        char buf[1000];
        memset(buf, '\0', sizeof(buf));
        strncat(buf, data_directory, strlen(data_directory));
        strncat(buf, "/data.db", 8);
        db->db_file = buf;
    }
    return db;
}

void DB_toDisk(struct database *db) {
    FILE *fp = fopen(db->db_file, "w+");
    if(!fp) return;

    struct Table *curr = db->head;
    while( curr != NULL ) {
        if(curr->head != NULL) {
            struct node *n = curr->head;
            while(n != NULL) {
                fwrite(curr->name, 1, strlen(curr->name), fp);
                fwrite("\t", 1, 1, fp);
                fwrite(n->key, 1, strlen(n->key), fp);
                int i;
                for(i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
                    if(strlen(n->col_values[i]) != 0) {
                        fwrite("\t", 1, 1, fp);
                        fwrite(curr->col_names[i], 1, strlen(curr->col_names[i]), fp);
                        fwrite("\t", 1, 1, fp);
                        fwrite(n->col_values[i], 1, strlen(n->col_values[i]), fp);
                    }
                }
                fwrite("\n", 1, 1, fp);
                n = n->next;
            }
        }
        curr = curr->next;
    }
    fclose(fp);
}

void DB_fromDisk(struct database *db) {
    FILE *fp = fopen(db->db_file, "r+");
    if(!fp) return;

    char *line = NULL;
    size_t len = 0;
    ssize_t read;

    while((read = getline(&line, &len, fp)) != -1) {
        char *name = NULL;
        char *key = NULL;

        name = strtok(line, "\t\n");
        key = strtok(NULL, "\t\n");

        while(1) {
            char *col = strtok(NULL, "\t\n");
            char *value = strtok(NULL, "\t\n");
            if(col == NULL || value == NULL) {
                break;
            }
            else {
                DB_set(db, name, key, col, value, 0);
            }
        }
    }
    if(line) {
        free(line);
    }
    fclose(fp);
}

/**
 * @brief 	Add a table to the database
 * @param 	db - the database to insert the table into
 * @param 	tablename - the name of the table to be inserted
 */
void DB_addTable (struct database *db, char *tablename) {
    struct Table *t = Table_init(tablename);
    if(db->head == NULL ) {
        db->head = t;

        db->head->prev = NULL;
        db->head->next = NULL;

        db->tail = db->head;
    }
    else {
        t->next = NULL;
        t->prev = db->tail;
        db->tail->next = t;
        db->tail = t;
    }
}

/**
 * @brief 	Retrieve a table from the database
 * @param 	db - the database that contains the table
 * @param 	tablename - the name of the table to be returned
 * @return	the found table, or NULL if not found.
 */
struct Table* DB_getTable (struct database *db, char *tablename) {
    struct Table *curr = db->head;

    while(curr != NULL) {
        if(strcmp(curr->name, tablename) == 0) {
            return curr;
        }
        curr = curr->next;
    }
    return NULL;
}

// columnName = name of column, char_string_size = 0 for int, > 0 for column of char_string_size size
// Return -1 if all columns are full, -2 if table DNE, 0 if insert was successful.
int DB_addColumn (struct database *db, char *tablename, char *columnName, int char_string_size) {
	struct Table *t = DB_getTable(db, tablename);
    if(t == NULL) {
        return -2;
    }
    return Table_addColumn(t, columnName, char_string_size);
}

/**
 * @brief 	Set a key / value pair to a table
 * @param 	db - the database that contains the table
 * @param 	tablename - the name of the table insert into
 * @param 	key - the key to insert or update
 * @param 	value - the value to insert or update
 * @return	-1 if table not found, -2 if key not found, 0 on success
 */
int DB_set (struct database *db, char *tablename, char *key, char *columnName, char *value, int persist) {
    struct Table *t = DB_getTable(db, tablename);
    if(t == NULL) { 
        return -1;
    }
    else {
        int stat = Table_set(t, key, columnName, value);
        if(stat == 0 && persist == 1) {
            DB_toDisk(db);
        }
        return stat;
    }
}

/*
 * @brief   Delete a node from the given database	
 * @param 	db - the database that contains the table
 * @param 	tablename - the name of the table insert into
 * @param 	key - the key to delete 
 * @return	-1 if table not found, -2 if key not found, 0 on success
 */
int DB_delete (struct database *db, char *tablename, char *key) {
    struct Table *t = DB_getTable(db, tablename);
    if(t == NULL) {
        return -1;
    }
    else {
        if(Table_delete(t, key) == -1) {
			return -2;
		}
    }
    DB_toDisk(db);
	return 0;
}

/*
 * @brief   Return a value from the database	
 * @param 	db - the database that contains the table
 * @param 	tablename - the name of the table insert into
 * @param   key - the key associated with the value to be returned
 * @param   returnVal - the string pointer for the found string to be stored in 
 * @return	-1 if table not found, -2 if key not found, 0 on success
 */
int DB_get (struct database *db, char *tablename, char *key, char *returnVal) {
    struct Table *t = DB_getTable(db, tablename);
    if(t == NULL) {
		return -1;
    }
	else {
        struct node *n = Table_get_node(t, key);
        if(n == NULL) {
			return -2;
		}
		else {
			char content[1000];
			memset(content, '\0', sizeof(content));
            memset(returnVal, '\0', sizeof(returnVal));
            int i;
			for (i = 0; i < MAX_COLUMNS_PER_TABLE; i++) {
				if(strlen(n->col_values[i]) > 0) {
                    strncat(content, t->col_names[i], strlen(t->col_names[i]));
                    strncat(content, ":", 1);
                    strncat(content, n->col_values[i], strlen(t->col_names[i]));
                    strncat(content, ";", 1);
			    }
            }
			strncat(returnVal, content, strlen(content));
            return 0;
        }
    }
}

int parse_record(struct database *db, char *tablename, char* key, char* the_value, char *returnString)
{
	struct Table *t = DB_getTable(db, tablename);
    	if(t == NULL) 
    	{
		strcpy(returnString, "E TABLE_NOT_FOUND");
		return -1;
    	}

	int predicate_cnt = 0;
	int col_per_table = 0;
	int stat;
    	while(1)
    	{
	// parse predicate string and store in a data structure
	char predicate_col_name[MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN];
	char predicate_col_value[MAX_COLUMNS_PER_TABLE][MAX_STRTYPE_SIZE];
	bool invalid_predicate = true;
	while(the_value[predicate_cnt] != '\0')
	{
		int col_name_cnt = 0;
		int col_value_cnt = 0;
		while((the_value[predicate_cnt] == ' ')&&(the_value[predicate_cnt] != '\0'))
		{
			predicate_cnt++;
		}
		while((the_value[predicate_cnt] != ' ')&&(the_value[predicate_cnt] != '\0'))
		{		
			if(isalnum(the_value[predicate_cnt]) == 0)
			{
				strcpy(returnString, "E INVALID_PARAM");
				return -2;
			}
					
			predicate_col_name[col_per_table][col_name_cnt] = the_value[predicate_cnt];
			predicate_cnt++;
			col_name_cnt++;
		}
		predicate_col_name[col_per_table][col_name_cnt+1] = '\0';
		while((the_value[predicate_cnt] == ' ')&&(the_value[predicate_cnt] != '\0'))
		{
			predicate_cnt++;
		}
		while((the_value[predicate_cnt] != ',')&&(the_value[predicate_cnt] != '\0'))
		{
			if(isalnum(the_value[predicate_cnt]) == 0)
			{
				if(the_value[predicate_cnt] != ' ')
				{
					strcpy(returnString, "E INVALID_PARAM");
					return -2;
				}
			}				
			predicate_col_name[col_per_table][col_name_cnt] = the_value[predicate_cnt];
			predicate_cnt++;
			col_name_cnt++;
		}
		int length = strlen(predicate_col_name[col_per_table]);
		while(predicate_col_name[col_per_table][length] == ' ')
		{
			predicate_col_name[col_per_table][length] == '\0';
			length--;
		}
		predicate_cnt++;
		col_per_table++;
	}
	// check for matching cases
	stat = check_record(db, t, key, predicate_col_name, predicate_col_value, returnString);
	return stat;
	}	
	
}

int check_record(struct database *db, struct Table* theTable, char* key, char** predicate_name, char** predicate_value, char*return_string)
{
	int predicate_names_cnt = 0;
	return_string[0] = 'S';
	int found = 0;
	while(predicate_name[predicate_names_cnt] != '\0')
	{
		int col_names_cnt = 0;
		while(theTable->col_names[col_names_cnt] != '\0')
		{
			if(strcmp(theTable->col_names[col_names_cnt], predicate_name[predicate_names_cnt]) == 0)
			{
				found = 1;
				if(theTable->col_string_size[col_names_cnt] == 0)
				{
					int value_cnt = 0;
					while(predicate_value[predicate_names_cnt][value_cnt] != '\0')
					{
						if(isdigit(predicate_value[predicate_names_cnt][value_cnt]) != 0)
						{
							strcpy(return_string, "E INVALID_PARAM");
							return -2;
						}
						value_cnt++;
					}
					
				}
				int stat = DB_set(db, theTable, key, predicate_name[predicate_names_cnt], predicate_value[predicate_names_cnt]);
				if(stat != 0)
				{
					return stat;
				}
			}
			col_names_cnt++;
		}
		if(found == 0)
		{
			strcpy(return_string, "E INVALID_PARAM");
			return -2;
		}
		found = 0;
		predicate_names_cnt++;
	}
	return 0;
}

/*
 * @brief   Print the entire database to the screen
 * @param   db - the database to print
 */
void DB_dump (struct database *db) {
    struct Table *curr = db->head;
    printf("** START DB DUMP **\n");
    while( curr != NULL ) {
        Table_dump(curr);
        curr = curr->next;
    }
    printf("** END DB DUMP **\n");
}

// An example function to show some usage
int DB_TEST(char *f) {
    struct database *db = DB_init(f);
	DB_addTable(db, "school");
	DB_addColumn(db, "school", "mark", 0);
    DB_addColumn(db, "school", "gender", 1);
    DB_addColumn(db, "school", "part_time", 0);
    DB_addColumn(db, "school", "age", 0);
    DB_addColumn(db, "school", "citizenship", 20);

    DB_addTable(db, "teams");
    DB_addColumn(db, "teams", "goals", 0);
    DB_addColumn(db, "teams", "sport", 20);

    DB_addTable(db, "cities");
    DB_addColumn(db, "cities", "avg_temp", 0);
    DB_addColumn(db, "cities", "population", 0);
    DB_addColumn(db, "cities", "province", 50);

    DB_fromDisk(db);
    //DB_set(db, "teams", "toronto", "goals", "82", 1);
    DB_dump(db);

/*    DB_set(db, "school", "jordan", "marks", "100", 1); 
    DB_set(db, "school", "jordan", "gender", "M", 1);
    DB_set(db, "school", "jordan", "citizenship", "canadian", 1);
    DB_set(db, "school", "jordan", "part_time", "1", 1);

    DB_set(db, "school", "xiang", "marks", "100", 1);
    DB_set(db, "school", "xiang", "gender", "F", 1);
    DB_set(db, "school", "xiang", "part_time", "0", 1);

    DB_set(db, "teams", "toronto", "goals", "10", 1);
    DB_set(db, "teams", "toronto", "sport", "hockey", 1);
    DB_set(db, "teams", "detroit", "goals", "50", 1);
    DB_set(db, "teams", "buffalo", "goals", "20", 1);

    DB_set(db, "cities", "toronto", "avg_temp", "5", 1);
    DB_set(db, "cities", "winnipeg","avg_temp",  "0", 1);
    DB_set(db, "cities", "nunavut", "avg_temp", "-10");
    DB_set(db, "cities", "winnipeg", "population", "2000000", 1);
    DB_set(db, "cities", "toronto", "province", "ontario", 1);

  */
    char buf[1000];
    memset(buf, '\0', sizeof(buf));
    DB_get(db, "school", "han", buf);
    if(strlen(buf) > 0)
        printf("%s\n", buf);

    return 0;
}

int main(int argc, char* argv[]) {
	DB_TEST(argv[1]);	
	return 0;
}

